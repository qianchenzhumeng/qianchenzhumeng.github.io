<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="使用 libusb 发送控制传输" /><meta name="author" content="前尘逐梦" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文以通过控制传输读取 HUB 的描述符为例，阐述如何为 HUB 添加 API，顺带对 libusb 中与 Windows 有关的源码进行剖析，也可以用在 HUB 以外的 USB 设备上。" /><meta property="og:description" content="本文以通过控制传输读取 HUB 的描述符为例，阐述如何为 HUB 添加 API，顺带对 libusb 中与 Windows 有关的源码进行剖析，也可以用在 HUB 以外的 USB 设备上。" /><link rel="canonical" href="https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" /><meta property="og:url" content="https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" /><meta property="og:site_name" content="前尘逐梦" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-16T20:45:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="使用 libusb 发送控制传输" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"前尘逐梦"},"description":"本文以通过控制传输读取 HUB 的描述符为例，阐述如何为 HUB 添加 API，顺带对 libusb 中与 Windows 有关的源码进行剖析，也可以用在 HUB 以外的 USB 设备上。","headline":"使用 libusb 发送控制传输","dateModified":"2021-11-16T20:45:00+08:00","datePublished":"2021-11-16T20:45:00+08:00","url":"https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/"},"@context":"https://schema.org"}</script><title>使用 libusb 发送控制传输 | 前尘逐梦</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">前尘逐梦</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/qianchenzhumeng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['qianchenzhumeng','live.cn'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <a href="https://www.thingiverse.com/mikeyu/designs" aria-label="" class="order-6" target="_blank" rel="noopener"> <i class="fas fa-cube"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>使用 libusb 发送控制传输</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>使用 libusb 发送控制传输</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Nov 16, 2021, 8:45 PM +0800" > Nov 16, 2021 <i class="unloaded">2021-11-16T20:45:00+08:00</i> </span> by <span class="author"> 前尘逐梦 </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3620 words">20 min</span></div></div><div class="post-content"><h2 id="1-背景">1. 背景</h2><p>最近要为 USB HUB 开发一个测试工具，基本功能包括获取描述符、发送 USB 标准请求等，选择从 libusb-1.0.24 着手进行开发。</p><h2 id="2-libusb-代码结构">2. libusb 代码结构</h2><p>总体看来，大致分为两层，第一层操作 <code class="language-plaintext highlighter-rouge">usbi_backend</code>，对外屏蔽操作系统的差异，下面还有一层后端，跟操作系统有关系，Windows 上可以选择 WinUSB 或 UsbDk。WinUSB 是 Windows 自带的驱动（<code class="language-plaintext highlighter-rouge">C:\Windows\System32\drivers\winusb.sys</code>），运行时库位为 <code class="language-plaintext highlighter-rouge">C:\Windows\System32\winusb.dll</code>，<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/usbcon/winusb">官网</a> 有详细的 API 使用文档。UsbDk 需要额外安装。</p><p>下图是大致阅读完代码后，整理出的一个结构图，可能会有因理解不到位造成的错误，仅供参考。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2021-11-16-send_a_usb_control_transfer_to_hub_using_libusb_on_windows.assets/libusb.png" alt="libusb" /></p><h3 id="1-windows">(1) Windows</h3><p>Windows 上，最底层默认为 <code class="language-plaintext highlighter-rouge">winusb_backend</code>，可以在 <code class="language-plaintext highlighter-rouge">windows_init</code> 中看到：</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// By default, new contexts will use the WinUSB backend</span>
<span class="n">priv</span><span class="o">-&gt;</span><span class="n">backend</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">winusb_backend</span><span class="p">;</span>
</pre></table></code></div></div><p>可以调用 <code class="language-plaintext highlighter-rouge">libusb_set_option</code> 函数切换后端，将其切换为 UsbDk。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">API_EXPORTED</span> <span class="n">libusb_set_option</span><span class="p">(</span><span class="n">libusb_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">enum</span> <span class="n">libusb_option</span> <span class="n">option</span><span class="p">,</span> <span class="p">...)</span>
</pre></table></code></div></div><p>其实还可以选择 libusbK，不过使用的后端变量还是 <code class="language-plaintext highlighter-rouge">winusb_backend</code>，详细情况可以参考 <code class="language-plaintext highlighter-rouge">winusbx_init</code> 函数的实现。</p><h3 id="2-linux">(2) Linux</h3><p>Linux 上，<code class="language-plaintext highlighter-rouge">usbi_backend</code> 封装了 usbfs 的接口。</p><p>扫描设备时，通过预编译宏 <code class="language-plaintext highlighter-rouge">HAVE_LIBUDEV</code> 决定使用 udev 还是 usbfs，该宏看起来是由 <code class="language-plaintext highlighter-rouge">configure</code> 控制的。</p><h2 id="3-获取描述符">3. 获取描述符</h2><h3 id="1-设备描述符">(1) 设备描述符</h3><ul><li>使用 <code class="language-plaintext highlighter-rouge">usbdk_backend</code><ul><li>在 <code class="language-plaintext highlighter-rouge">usbdk_device_init</code> 中，从 <code class="language-plaintext highlighter-rouge">usbdk_get_device_list</code> 传递进来的设备信息中复制设备描述符，后者调用 UsbDk 的接口 <code class="language-plaintext highlighter-rouge">UsbDk_GetDevicesList</code> 获取设备信息。</ul><li>使用 <code class="language-plaintext highlighter-rouge">winusb_backend</code>(默认)<ul><li><code class="language-plaintext highlighter-rouge">init_device</code> 中，通过调用操作系统的接口 <code class="language-plaintext highlighter-rouge">DeviceIoControl</code> 获取设备信息，然后从获取的设备信息中拷贝设备描述符。</ul></ul><h3 id="2-配置描述符">(2) 配置描述符</h3><p><code class="language-plaintext highlighter-rouge">get_config_descriptor</code> 中调用 <code class="language-plaintext highlighter-rouge">usbi_backend</code> 的函数指针获取</p><ul><li>使用 <code class="language-plaintext highlighter-rouge">usbdk_backend</code><ul><li>最终通过 <code class="language-plaintext highlighter-rouge">UsbDk_GetConfigurationDescriptor</code> 获取配置描述符。</ul><li>使用 <code class="language-plaintext highlighter-rouge">winusb_backend</code>(默认)<ul><li><code class="language-plaintext highlighter-rouge">winusb_get_config_descriptor</code> 中复制之前已经缓存的配置描述符（<code class="language-plaintext highlighter-rouge">init_device</code> 中缓存的）</ul></ul><h3 id="3-接口描述符">(3) 接口描述符</h3><p>接口描述符是配置描述符内容的一部分，从配置描述符的结构体中取即可。</p><h3 id="4-端点描述符">(4) 端点描述符</h3><p>是接口描述符内容的一部分，从接口描述符的结构体中取即可。</p><h3 id="5超高速端点伴侣描述符">(5)超高速端点伴侣描述符</h3><p>调用 <code class="language-plaintext highlighter-rouge">libusb_get_ss_endpoint_companion_descriptor</code> 获取，该函数在端点描述符的基础上进行一系列偏移后得到超高速端点伴侣描述符。</p><h3 id="6获取-bos-描述符">(6)获取 BOS 描述符</h3><p>获取 BOS 描述符的接口与获取设备描述符的接口不同，需要先打开设备，获得设备句柄，然后通过控制传输获取。</p><h3 id="7-获取字符串描述符">(7) 获取字符串描述符</h3><p>和获取 BOS 描述符的操作类似，需要先打开设备，获得设备句柄，然后通过控制传输获取。</p><h2 id="4-如何获取-hub-的描述符">4. 如何获取 HUB 的描述符</h2><p>不管选用哪种后端，都可以获取设备描述符、配置描述符、接口描述符、端点描述符、超高速端点伴侣描述符，这些描述符都是从操作系统缓存好的信息中拿出来的，无需额外发起控制传输。像 BOS 描述符、字符串描述符、HUB 类描述符都需要额外发起控制传输才能获取，而发起控制传输的必要条件是要获得设备句柄以及接口句柄。如前面讲的，<code class="language-plaintext highlighter-rouge">usb_api_backend</code> 中并未给 HUB 定义相关的 API。</p><p>尝试切换 <code class="language-plaintext highlighter-rouge">usbdk_backend</code> 后端：</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">libusb_set_option</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">LIBUSB_OPTION_USE_USBDK</span><span class="p">);</span>
</pre></table></code></div></div><p>提示不支持：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>[ 0.002677] [000042c0] libusb: debug [windows_iocp_thread] I/O completion thread started
[ 0.002770] [000011a4] libusb: error [windows_set_option] UsbDk backend not available
</pre></table></code></div></div><p>需要根据这篇文章安装 <a href="https://cgit.freedesktop.org/spice/win32/usbdk">UsbDk</a>：<a href="https://github.com/libusb/libusb/wiki/Windows#Driver_Installation">https://github.com/libusb/libusb/wiki/Windows#Driver_Installation</a>。但是安装好后也有问题：在 64 位机器上使用最新版本（v1.00-22），访问 HUB 时 Windows 会崩溃，出现蓝屏错误。v1.00-17 和 v1.00-16 更离谱，一旦安装，USB 设备就无法用了（<strong>不建议安装 UsbDk，风险有点大。多亏之前允许过远程连接，鼠标、键盘没法用的话，还可以通过远程连接登录上去，把 usbDk 卸载掉</strong>）。</p><p>如果选择 <code class="language-plaintext highlighter-rouge">winusb_backend</code> 后端，还需要在 <code class="language-plaintext highlighter-rouge">usb_api_backend</code> 为 HUB 添加对应的 API，可以仿照 <code class="language-plaintext highlighter-rouge">USB_API_WINUSBX</code> 的接口为 HUB 封装必要的接口。而且还需要将 HUB 的驱动更换为 WinUSB，才能通过 WinUSB 接口访问 HUB（默认的驱动是 USBHUB3.SYS，不对外开放，没有 API 使用说明），可以借助 <a href="https://zadig.akeo.ie/">Zadig</a> 更换 HUB 的驱动。需要注意的是，将 HUB 的驱动切换成 WinUSB 后，虽然可以通过控制传输向 HUB 发送命令，但是 HUB 会失去 HUB 的功能，例如，下行口接上设备时，电脑并不能识别到这个设备。从抓包分析的结果来看，换用 WinUSB 驱动后，PC 仅会完成 HUB 的枚举过程，后续的端口上电、使能、复位流程都没有。</p><p>使用 Zadig 为 HUB 换驱动时，需要在 <code class="language-plaintext highlighter-rouge">Options</code> 菜单中勾选 <code class="language-plaintext highlighter-rouge">List All Devices</code>，并且取消对 <code class="language-plaintext highlighter-rouge">Ignore Hubs or Composite Parents</code> 的勾选，否则无法看到 HUB。</p><h2 id="5-获取设备句柄以及接口句柄">5. 获取设备句柄以及接口句柄</h2><p>获取句柄的过程：调用 <code class="language-plaintext highlighter-rouge">usbi_backend</code> 的 <code class="language-plaintext highlighter-rouge">open</code> 函数指针，该指针指向 <code class="language-plaintext highlighter-rouge">windows_common.c</code> 中的 <code class="language-plaintext highlighter-rouge">windows_open</code> 函数，该函数内，会调用第二层后端的 <code class="language-plaintext highlighter-rouge">open</code> 函数。</p><h3 id="1-winusb_backend">(1) winusb_backend</h3><p>该后端使用 <code class="language-plaintext highlighter-rouge">usb_api_backend</code> 中的回调函数。<code class="language-plaintext highlighter-rouge">usb_api_backend</code> 定义了 5 组 API（在 <code class="language-plaintext highlighter-rouge">windows_winusb.c</code> 中）：</p><ul><li>USB_API_UNSUPPORTED<li>USB_API_HUB<li>USB_API_COMPOSITE<li>USB_API_WINUSBX<li>USB_API_HID</ul><p>只有后三种有 <code class="language-plaintext highlighter-rouge">open</code> 函数，即前两种不支持获取设备句柄。</p><p>使用 <code class="language-plaintext highlighter-rouge">winusb_backend</code> 后端时，会提示不支持 HUB 的 <code class="language-plaintext highlighter-rouge">open</code> 操作：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>Dev (bus 1, device 4): 05E3 - 0610 speed: 480M						// 2.0 HUB
[ 0.018514] [00003c5c] libusb: debug [libusb_open] open 1.4
[ 0.018586] [00003c5c] libusb: debug [winusb_open] unsupported API call for 'open' (unrecognized device driver)
[ 0.018676] [00003c5c] libusb: debug [libusb_open] open 1.4 returns -12
[ 0.018751] [00003c5c] libusb: debug [libusb_get_device_descriptor]
Dev (bus 1, device 3): 05E3 - 0626 speed: 5G						// 3.0 HUB
[ 0.018890] [00003c5c] libusb: debug [libusb_open] open 1.3
[ 0.018961] [00003c5c] libusb: debug [winusb_open] unsupported API call for 'open' (unrecognized device driver)
[ 0.019051] [00003c5c] libusb: debug [libusb_open] open 1.3 returns -12
[ 0.019125] [00003c5c] libusb: debug [libusb_get_device_descriptor]
Dev (bus 1, device 0): 8086 - A3AF speed: 5G						// 3.0 根集线器
[ 0.019265] [00003c5c] libusb: debug [libusb_open] open 1.0
[ 0.019334] [00003c5c] libusb: debug [winusb_open] unsupported API call for 'open' (unrecognized device driver)
[ 0.019427] [00003c5c] libusb: debug [libusb_open] open 1.0 returns -12
[ 0.019504] [00003c5c] libusb: debug [libusb_get_device_descriptor]
</pre></table></code></div></div><p>正如前文所述，需要给 HUB 添加 API，获取到设备句柄以及接口句柄，涉及三个函数，初始化、打开、关闭，对应于 <code class="language-plaintext highlighter-rouge">windows_usb_api_backend</code> 的如下函数指针：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>bool (*init)(struct libusb_context *ctx);
void (*exit)(void);
int (*open)(int sub_api, struct libusb_device_handle *dev_handle);
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">init</code> 函数要完成加载 <code class="language-plaintext highlighter-rouge">WinUSB</code> 运行时库，查找并储存相关函数地址的工作，可以参照 <code class="language-plaintext highlighter-rouge">winusbx_init</code> 编写。</p><p><code class="language-plaintext highlighter-rouge">exit</code> 函数要完成清理工作，可以参照 <code class="language-plaintext highlighter-rouge">winusbx_exit</code> 编写。</p><p><code class="language-plaintext highlighter-rouge">open</code> 函数比较重要，我们要在该函数中获取到 HUB 的设备句柄和接口句柄，并且，还要建立接口句柄和后文提到的 I/O completion port 的关联关系。可以参照 <code class="language-plaintext highlighter-rouge">winusbx_open</code> 以及 <code class="language-plaintext highlighter-rouge">windows_open</code> 编写。</p><p>需要注意，HUB 的驱动要和使用的后端匹配，比如，使用 WinUSB，那么 HUB 的驱动就要改成 WinUSB，使用 libusbK，那么 HUB 的驱动就要改成 libusbK，否则，会出现接口句柄获取失败或控制传输下发失败的问题（函数会返回成功，但是实际上没有发出去）的情况。</p><h3 id="2-usbdk_backend">(2) usbdk_backend</h3><p>通过 <code class="language-plaintext highlighter-rouge">usbdk_helper</code> 获取设备句柄，<code class="language-plaintext highlighter-rouge">usbdk_helper</code> 的回调函数地址都是从系统的 <code class="language-plaintext highlighter-rouge">UsbDkHelper.dll</code> 动态库中获取的。</p><h2 id="6-下发-usb-请求">6. 下发 USB 请求</h2><p>USB 请求是通过控制传输下发的。<code class="language-plaintext highlighter-rouge">windows_usb_api_backend</code> 结构体中，与控制传输相关的函数指针有三个：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>int (*submit_control_transfer)(int sub_api, struct usbi_transfer *itransfer);
int (*cancel_transfer)(int sub_api, struct usbi_transfer *itransfer);
enum libusb_transfer_status (*copy_transfer_data)(int sub_api, struct usbi_transfer *itransfer, DWORD length);
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">submit_control_transfer</code> 发起控制传输，可以仿照 <code class="language-plaintext highlighter-rouge">winusbx_submit_control_transfer</code> 编写。</p><p><code class="language-plaintext highlighter-rouge">cancel_transfer</code> 取消控制传输，可以仿照 <code class="language-plaintext highlighter-rouge">winusbx_cancel_transfer</code> 编写。</p><p><code class="language-plaintext highlighter-rouge">copy_transfer_data</code> 用于获取 IN 传输的结果，可以仿照 <code class="language-plaintext highlighter-rouge">winusbx_copy_transfer_data</code> 编写。</p><h3 id="1-标准请求">(1) 标准请求</h3><p>标准请求可以通过 <code class="language-plaintext highlighter-rouge">libusb_control_transfer</code> 下发，使用方法可以参考 <code class="language-plaintext highlighter-rouge">testlibusb.c</code> 示例，追踪获取字符串描述符的函数 <code class="language-plaintext highlighter-rouge">libusb_get_string_descriptor_ascii</code>，该函数会调用 <code class="language-plaintext highlighter-rouge">libusb_control_transfer</code>。</p><h3 id="2-供应商指令">(2) 供应商指令</h3><p>供应商指令也是通过控制传输下发的，使用方法可以参考源码中的示例 <code class="language-plaintext highlighter-rouge">ezusb.c</code>。</p><h2 id="7-事件处理">7. 事件处理</h2><p>本节要解决的问题：分析控制传输相关的事件源于哪里？处理流程是什么样的？</p><h3 id="1-事件源">(1) 事件源</h3><p>时间源是在 <code class="language-plaintext highlighter-rouge">usbi_io_init</code> 中设置的。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>usbi_io_init
-&gt; usbi_create_event
   -&gt; CreateEvent	# 操作系统接口
-&gt; usbi_add_event_source # 将事件源加入事件源链表
   -&gt; 将事件源加入事件源链表 ctx-&gt;event_sources（事件源的数据为 USBI_EVENT_POLL_EVENTS，值为 0）
   -&gt; usbi_event_source_notification
      -&gt; ctx-&gt;event_flags |= USBI_EVENT_EVENT_SOURCES_MODIFIED;
      -&gt; usbi_signal_event	# 如果尚未设置 event_flags 为 0 则
         -&gt; SetEvent	# 将事件对象设置为 signaled 状态，目的应该是处理上面的 USBI_EVENT_EVENT_SOURCES_MODIFIED 事件。
</pre></table></code></div></div><p>这个地方其实仅仅只是创建了事件对象，还没有具体的意义。</p><h3 id="2-等待">(2) 等待</h3><p>在 <code class="language-plaintext highlighter-rouge">libusb_control_transfer</code> 函数中发起控制传输后，程序会进入等待传输完成流程：</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sync_transfer_wait_for_completion</span><span class="p">(</span><span class="n">transfer</span><span class="p">)</span>
</pre></table></code></div></div><p>该函数中，会以死循环的形式等待传输完成标志 <code class="language-plaintext highlighter-rouge">transfer-&gt;user_data</code> 变为非 0 值。</p><p>有如下调用链：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>sync_transfer_wait_for_completion
-&gt; libusb_handle_events_completed
   -&gt; libusb_handle_events_completed # 设置超时时间（60s）
      -&gt; libusb_handle_events_timeout_completed
         -&gt; handle_events
            -&gt; usbi_alloc_event_data # 处理 USBI_EVENT_EVENT_SOURCES_MODIFIED 事件
            -&gt; usbi_wait_for_events	# 等待事件，设置事件触发标志
               -&gt; WaitForMultipleObjects # 操作系统的接口，等待的对象是由 usbi_alloc_event_data 中分配的句柄来指定的
            -&gt; handle_event_trigger # 根据 ctx-&gt;event_flags 处理不同的事件
               -&gt; usbi_backend.handle_transfer_completion	# 指向 windows_handle_transfer_completion
                  -&gt; GetOverlappedResult # 操作系统的接口，获取 overlapped operation 的结果
                  -&gt; backend-&gt;copy_transfer_data 
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">WaitForMultipleObjects</code> 是操作系统的接口，参见 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects function (synchapi.h)</a>，等待实际上就是在这个位置进行的。</p><p><code class="language-plaintext highlighter-rouge">GetOverlappedResult</code> 是操作系统的接口，获取针对某个文件（通过入参指定）进行 overlapped operation 的结果，参见 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult function (ioapiset.h)</a>。这里的文件句柄是 HUB 设备对应的句柄。</p><h3 id="3-触发">(3) 触发</h3><p>通过上面的调用链可以看到，event_data 所需的内存是在 <code class="language-plaintext highlighter-rouge">usbi_alloc_event_data</code> 中分配的，那么，<code class="language-plaintext highlighter-rouge">usbi_alloc_event_data</code> 中的事件和要等待的控制传输完成事件是如何关联的，换句话说，就是事件是如何触发的？</p><p>实际上，<code class="language-plaintext highlighter-rouge">usbi_alloc_event_data</code> 不涉及设定关联关系，仅用来处理 <code class="language-plaintext highlighter-rouge">USBI_EVENT_EVENT_SOURCES_MODIFIED</code> 事件，根据事件源列表中的事件源数量（最多限制为 2 个，一个为控制传输完成事件，另一个为定时器超时时间），为 <code class="language-plaintext highlighter-rouge">ctx-&gt;event_data</code> 分配内存空间。</p><p>事件触发有两种方式，一种是主动强行触发，另一种是等待操作系统的信号。</p><p>关联关系是通过事件对象的使用方式建立的。从微软网站上的文档来看，事件的使用方式是这样的：A 函数监听该事件，要触发该事件的话，需要在另外的地方将事件对象设置为 signaled 状态，这样的话，监听该事件的 A 函数会被释放，完成后续的处理。</p><p>设置事件对象为 signaled 状态的地方有 6 处：</p><ol><li><code class="language-plaintext highlighter-rouge">libusb_close</code><li><code class="language-plaintext highlighter-rouge">usbi_signal_transfer_completion</code><li><code class="language-plaintext highlighter-rouge">libusb_interrupt_event_handler</code><li><code class="language-plaintext highlighter-rouge">usbi_event_source_notification</code><li><code class="language-plaintext highlighter-rouge">usbi_hotplug_notification</code><li><code class="language-plaintext highlighter-rouge">libusb_hotplug_deregister_callback</code></ol><p>看起来仅有 2 和 4 跟这里的分析有关系，跟控制传输完成事件相关的仅有 2：</p><p><code class="language-plaintext highlighter-rouge">usbi_signal_transfer_completion</code> 有两处调用：</p><ul><li><code class="language-plaintext highlighter-rouge">windows_force_sync_completion</code><li><code class="language-plaintext highlighter-rouge">windows_iocp_thread</code></ul><p><code class="language-plaintext highlighter-rouge">usbi_event_source_notification</code> 有两处调用：</p><ul><li><code class="language-plaintext highlighter-rouge">usbi_add_event_source</code><li><code class="language-plaintext highlighter-rouge">usbi_remove_event_source</code></ul><p><code class="language-plaintext highlighter-rouge">usbi_signal_transfer_completion</code> 的两处调用，对应着前面说的两种触发方式。</p><p>一是发起控制传输后，通过 <code class="language-plaintext highlighter-rouge">windows_force_sync_completion</code> 强行触发，有如下调用链：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>windows_force_sync_completion
-&gt; usbi_signal_transfer_completion # 设置 ctx 中的事件标志，设置为已完成
   -&gt; usbi_signal_event
      -&gt; SetEvent
</pre></table></code></div></div><p>这个 <code class="language-plaintext highlighter-rouge">SetEvent</code> 是操作系统的接口，作用就是前面讲的将指定的事件对象设置为 signaled 状态。详见 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent function (synchapi.h)</a>。</p><p>简单来说，强行触发是将对应的事件对象设置为 signaled 状态，这样的话，等待该事件对象的函数就可以被触发了。<code class="language-plaintext highlighter-rouge">winusbx_submit_control_transfer</code> 函数中，发起 <code class="language-plaintext highlighter-rouge">Set_Configuration</code> 请求后，会以强行触发的方式通知等待函数控制传输已完成。</p><p>另外一种呢？<code class="language-plaintext highlighter-rouge">usbi_signal_transfer_completion</code> 被调用的另一处地方在 <code class="language-plaintext highlighter-rouge">windows_iocp_thread</code> 函数内。</p><p><code class="language-plaintext highlighter-rouge">libusb_init</code> 调用的 <code class="language-plaintext highlighter-rouge">windows_init</code> 函数会创建一个等待 I/O 完成的线程，该线程的入口函数就是 <code class="language-plaintext highlighter-rouge">windows_iocp_thread</code>。</p><p><code class="language-plaintext highlighter-rouge">windows_iocp_thread</code> 函数在死循环中有如下调用链：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>windows_iocp_thread
-&gt; GetQueuedCompletionStatus # 会一直阻塞在这个地方，直到有完成或者退出时才会往下进行
   -&gt; usbi_signal_transfer_completion
</pre></table></code></div></div><p>这种就是第二种情况，即等待操作系统完成事件的情况。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>GetQueuedCompletionStatus(iocp, &amp;num_bytes, &amp;completion_key, &amp;overlapped, INFINITE)
</pre></table></code></div></div><p>iocp 是 <code class="language-plaintext highlighter-rouge">windows_init</code> 中通过 <code class="language-plaintext highlighter-rouge">CreateIoCompletionPort</code> 创建的 I/O completion port，创建的时候未和任何文件句柄关联，存放在 ctx 的 <code class="language-plaintext highlighter-rouge">priv-&gt;completion_port</code> 中。</p><p>在 <code class="language-plaintext highlighter-rouge">windows_winusb.c</code> 文件的 <code class="language-plaintext highlighter-rouge">windows_open</code> 函数中，ctx 的 <code class="language-plaintext highlighter-rouge">priv-&gt;completion_port</code> 和设备的接口的 path 关联到了一起。前文提到事件对象和控制传输完成这一物理事件的对应关系就是在这个地方建立的。</p><h3 id="4-小结">(4) 小结</h3><p>libusb 使用操作系统提供的事件对象来获知控制传输是否完成。等待方需要通过 <code class="language-plaintext highlighter-rouge">WaitForMultipleObjects</code> 等待事件。触发该事件的方式有两种，一种是强行触发，即程序主动将事件对象设置为 signaled 状态，另一种是通过 <code class="language-plaintext highlighter-rouge">GetQueuedCompletionStatus</code> 等待 overlapped 操作完成，完成后将事件对象设置为 signaled 状态。事件对象的状态变为 signaled 状态时，等待该事件的函数会被释放。</p><h2 id="8-调试">8. 调试</h2><p>libusb 有非常丰富的调试信息，打开调试输出的方式有两种，一种是调用 <code class="language-plaintext highlighter-rouge">libusb_set_option</code> 函数，设置输出级别；另一种是设置环境变量 <code class="language-plaintext highlighter-rouge">LIBUSB_DEBUG</code> 来设置输出级别。</p><p>例如，cmd 上：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>set LIBUSB_DEBUG=4
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/embedded/'>Embedded</a>, <a href='/categories/usb/'>USB</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/usb/" class="post-tag no-text-decoration" >USB</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=使用 libusb 发送控制传输 - 前尘逐梦&url=https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=使用 libusb 发送控制传输 - 前尘逐梦&u=https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=使用 libusb 发送控制传输 - 前尘逐梦&url=https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="http://service.weibo.com/share/share.php?title=使用 libusb 发送控制传输 - 前尘逐梦&url=https://qianchenzhumeng.github.io/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/mq-r-f133_develop_guide/">芒果派 MQ-R F133 开发指南</a><li><a href="/posts/gui_development_with_rust_and_gtk4_on_windows/">Windows 下使用 Rust 和 GTK4 创建 GUI 程序</a><li><a href="/posts/modern_robotics_mechanics_planning_and_Control/">Modern Robotics: Mechanics, Planning, and Control</a><li><a href="/posts/rust_notes/">Rust 笔记</a><li><a href="/posts/generate_manufacturing_data_from_eagle/">Eagle 输出 PCB 制造数据</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mqtt/">MQTT</a> <a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/rust/">Rust</a> <a class="post-tag" href="/tags/thingsboard/">ThingsBoard</a> <a class="post-tag" href="/tags/contiki/">Contiki</a> <a class="post-tag" href="/tags/esp8266/">ESP8266</a> <a class="post-tag" href="/tags/stm8/">STM8</a> <a class="post-tag" href="/tags/inventory-management/">Inventory Management</a> <a class="post-tag" href="/tags/iot/">IoT</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/compile_openwrt_for_mt7688/"><div class="card-body"> <span class="timeago small" > Aug 28, 2021 <i class="unloaded">2021-08-28T08:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenWrt 编译</h3><div class="text-muted small"><p> 1. 背景 处理器：MT7688 OpenWrt版本：19.07.2 编译环境：wsl（Ubuntu 20.04.1 LTS） 2. 下载源码 源码地址：https://github.com/openwrt/openwrt 可以通过 gitee 加速代码下载，具体做法是在 gitee 上通过“从GitHub/GitLab导入仓库”的形式创建仓库，等创建好后，从 git...</p></div></div></a></div><div class="card"> <a href="/posts/IAR%E7%BC%96%E8%AF%91ZStack-CC2530%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/"><div class="card-body"> <span class="timeago small" > Aug 25, 2015 <i class="unloaded">2015-08-25T00:11:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IAR 编译 ZStack-CC2530 生成 HEX 文件</h3><div class="text-muted small"><p> IAR 编译 ZStack-CC2530 为可下载运行的 HEX 文件的正确配置： 正确配置输出文件格式：菜单选择Project－Options－Linker－Output－Format，选择Other。右边的Output下拉框选intel-extended，Format variant下拉框选None，Module-local下拉框选Include all ...</p></div></div></a></div><div class="card"> <a href="/posts/Qt_Embedded(4.8.6)%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><div class="card-body"> <span class="timeago small" > Aug 25, 2015 <i class="unloaded">2015-08-25T00:11:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Qt/Embeded(4.8.6)交叉编译环境搭建</h3><div class="text-muted small"><p> 目标板为树莓派，安装镜像为：2014-12-24-wheezy-raspbian.img 安装交叉编译器： 下载：gcc-linaro-arm-linux-gnueabihf-raspbian-x64 解压后将bin目录添加进~/.profile文件中，例如： PATH=/home/qianchen/rpi/tools/arm-bcm2708/gcc-linaro-arm-linu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/modern_robotics_mechanics_planning_and_Control/" class="btn btn-outline-primary" prompt="Older"><p>Modern Robotics: Mechanics, Planning, and Control</p></a> <a href="/posts/keil_hex_file_format/" class="btn btn-outline-primary" prompt="Newer"><p>Keil HEX 文件格式解析及数据提取</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/qianchenzhumeng">前尘逐梦</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/mqtt/">MQTT</a> <a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/rust/">Rust</a> <a class="post-tag" href="/tags/thingsboard/">ThingsBoard</a> <a class="post-tag" href="/tags/contiki/">Contiki</a> <a class="post-tag" href="/tags/esp8266/">ESP8266</a> <a class="post-tag" href="/tags/stm8/">STM8</a> <a class="post-tag" href="/tags/inventory-management/">Inventory Management</a> <a class="post-tag" href="/tags/iot/">IoT</a> <a class="post-tag" href="/tags/other/">Other</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?0dfbba74f4bbf4feedaaf402fbae1dd8"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://qianchenzhumeng.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
