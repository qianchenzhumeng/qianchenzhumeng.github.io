[ { "title": "为芒果派 MQ-R F133 编译 iot_gw 网关", "url": "/posts/build_iot_gw_for_mq-r-f133.md/", "categories": "Embedded, OpenWrt", "tags": "OpenWrt", "date": "2022-10-27 23:26:00 +0800", "snippet": "前前后后花了大概半个月的时间，总算完成了两件事： 为 iot_gw 替换串口库，避免移植到新平台时适配串口的繁琐流程。 为芒果派 MQ-R F133 编译 iot_gw 网关。RUST 和 RISC-V，都是比较新的东西，二者结合的时候，遇到的问题也比较多。这次编译主要卡在 openssl、paho-mqtt-sys 的编译上，概括来说，有以下几个方面： 老版本的 openssl，比如 openssl-1.0.2l，没有 riscv 的配置，使用 riscv64-unknown-linux-gnu 工具链编译时，最后编译出的库格式无法被链接器识别。 riscv64gc-unkno..." }, { "title": "芒果派 MQ-R F133 开发指南", "url": "/posts/mq-r-f133_develop_guide/", "categories": "Embedded, OpenWrt", "tags": "OpenWrt", "date": "2022-10-17 00:04:00 +0800", "snippet": "1. 开发环境搭建搭建开发环境比较简单，芒果派 Tina-Linux 代码库的自述文件中有在 Ubuntu18.04 上搭建 F133 开发环境的的指导，唯一比较折磨人的问题是下载 SDK 的时间比较久。如果是在 WSL 中搭建开发环境，需要注意以下两个问题： 注意不要将 Tina-Linux 随意放置在 C 盘、D 盘等位置上，实测这样做的时候，即使对应目录开启了大小写敏感，编译时也会发生莫名其妙的问题。需要放置在 WSL 用户的家目录下，编译才能正常进行。 确保 WSL 的版本是 2。编译打包的过程会调用一些工具，有一部分工具是 32 位的，WSL1 不支持运行 32 位程序，需..." }, { "title": "如何使用 Gitlab 进行嵌入式项目管理", "url": "/posts/how_to_management_embedded_projects_using_gitlab/", "categories": "Embedded, Other", "tags": "Other", "date": "2022-04-10 15:04:00 +0800", "snippet": "1. 背景对于体量比较小的嵌入式项目来说，如果打算自建项目管理系统，那么 Gitlab 是个不错的选择，像源代码版本控制、制品管理、故障跟踪，甚至需求管理，都可以在 Gitlab 完成。2. Gitlab 安装及启动安装过程相对简单，以 Ubuntu 为例，安装社区版：curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bashsudo apt-get install gitlab-ce这就安装好了。当然，如果是在服务器上安装，那还要进行更多的配置，按..." }, { "title": "Windows 下使用 Rust 和 GTK4 创建 GUI 程序", "url": "/posts/gui_development_with_rust_and_gtk4_on_windows/", "categories": "Rust", "tags": "Rust", "date": "2022-03-26 13:50:00 +0800", "snippet": "1. 准备开发环境(1) 安装 GUN 工具链MinGW 是在 Windows 上用于 Windows 原生应用开发的 GNU 工具链，安装方式有两种，一种是使用 MinGW 安装管理器进行安装，另一种是通过 MSYS2 进行安装。相比于 MinGW 安装器，MSYS2 提供的功能更丰富，可以访问 MSYS2 的官方网站[1]获取具体的介绍信息。MSYS2 的官网首页给出了 MSYS2 的安装方式，其中包含了 MSYS2 安装好之后，使用内部集成的 pacman 包管理器安装 mingw-w64 的步骤。将 MinGW 的如下目录添加到环境变量中： C:\\msys64\\mingw64\\..." }, { "title": "Keil HEX 文件格式解析及数据提取", "url": "/posts/keil_hex_file_format/", "categories": "Embedded, MCU", "tags": "Keil", "date": "2022-02-13 21:15:00 +0800", "snippet": "1. 背景进行 MCU OTA 升级调试时，升级重启后，MCU 程序跑飞，怀疑程序下载缓冲区的内容被改写，为了排除这个疑点，需要将缓冲区内的数据与编译生成的 BIN 文件或 HEX 文件内的数据进行比对。思路是将数据以文本形式输出到文件中，使用文件比对工具进行比对。Keil 的 SAVE 调试命令会将下载缓冲区中的数据输出到 Intel HEX 格式[1]的文件中，虽然编译生成的 *.hex 文件也是该格式，但是二者有时不能直接对比：前者的地址会从 0x0000 开始，但是编译生成的 *.hex 文件内记录的起始地址与实际指定的程序烧录地址有关，但是数据是一样的。因此，需要从这两个文件中..." }, { "title": "使用 libusb 发送控制传输", "url": "/posts/send_a_usb_control_transfer_to_hub_using_libusb_on_windows/", "categories": "Embedded, USB", "tags": "USB", "date": "2021-11-16 20:45:00 +0800", "snippet": "1. 背景最近要为 USB HUB 开发一个测试工具，基本功能包括获取描述符、发送 USB 标准请求等，选择从 libusb-1.0.24 着手进行开发。2. libusb 代码结构总体看来，大致分为两层，第一层操作 usbi_backend，对外屏蔽操作系统的差异，下面还有一层后端，跟操作系统有关系，Windows 上可以选择 WinUSB 或 UsbDk。WinUSB 是 Windows 自带的驱动（C:\\Windows\\System32\\drivers\\winusb.sys），运行时库位为 C:\\Windows\\System32\\winusb.dll，官网 有详细的 API 使用文..." }, { "title": "Modern Robotics: Mechanics, Planning, and Control", "url": "/posts/modern_robotics_mechanics_planning_and_Control/", "categories": "Other", "tags": "Robot", "date": "2021-11-14 22:25:00 +0800", "snippet": "之前学习了 Coursera 上的 機器人學一 (Robotics (1))，对机械臂的运动学分析以及路径规划有了大致了解，课程后期的测验题涉及了大量的三角函数运算，手算几乎不太可能，由于缺乏编程求解方面的详细指导，后面的题目也没有做出来。看了一下 Modern Robotics: Mechanics, Planning, and Control 专项课程 的简介，有编程方面的指导，也有模拟软件使用方面的教学，学起来应该透彻一些，打算花半年到一年的时间学完该专项课程中的 6 门课。1. 课程 1学习如何使用 CoppeliaSim 模拟器：Getting Started with the..." }, { "title": "Rust USB 开发", "url": "/posts/rust_usb_programming/", "categories": "Rust, Other", "tags": "Rust", "date": "2021-11-03 21:13:00 +0800", "snippet": "1. 背景最近在参与 USB 相关的项目，需要开发一个测试工具，用于最终产品的量产配置、测试，预计运行在 Windows 上。我从微软的网站上找到了为 USB 设备开发桌面应用的两篇文章：《为 USB 设备开发 Windows 应用程序的概述》《USB 设备的 Windows 桌面应用》，文章提到了两种实现方式，一是使用 Visual Studio 创建包含 WindUSB 的模板，基于这个模板进行开发，二是使用 WinUSB 函数访问 USB 设备，后者给的教程也是基于 WindUSB 模板创建主干应用……使用 Visual Studio 有点麻烦，想试试不用 Visual Studi..." }, { "title": "用 Rust 实现 MIN 协议", "url": "/posts/implemente_min_protocol_in_rust/", "categories": "Rust, Other", "tags": "Rust", "date": "2021-08-29 09:29:00 +0800", "snippet": "1. 背景MIN 协议，全称 Microcontroller Interconnect Network protocol，是为微控制器和微控制器或者微控制器和 PC 设计的点对点传输协议，工作在串口上面，可发送任意数据，支持校验、重传机制。之前一直想做一个 Lora 网关，尝试过树莓派和 Lora 模块组合的形式，树莓派上跑 Eclipse 的 Kura 网关，通过 SPI 接口控制、访问 Lora 模块。Lora 模块上没有 CPU，直接就是 Lora 射频收发芯片加外围电路，在 Kura 框架下，用 java 操作 SPI 还是比较难受的，而且来自 Lora 模块的中断也比较难处理，..." }, { "title": "OpenWrt 编译", "url": "/posts/compile_openwrt_for_mt7688/", "categories": "Embedded, OpenWrt", "tags": "OpenWrt", "date": "2021-08-28 08:00:00 +0800", "snippet": "1. 背景 处理器：MT7688 OpenWrt版本：19.07.2 编译环境：wsl（Ubuntu 20.04.1 LTS）2. 下载源码源码地址：https://github.com/openwrt/openwrt可以通过 gitee 加速代码下载，具体做法是在 gitee 上通过“从GitHub/GitLab导入仓库”的形式创建仓库，等创建好后，从 gitee 克隆该仓库。如果需要对源码做些修改，并且希望可以保存下来，建议自己新建仓库，后续将更改提交到该仓库；如果不需要保存，直接克隆 gitee 上已有的 OpenWrt 的源码克隆仓库就可以了：git clone git@g..." }, { "title": "嵌入式系统程序占用空间大小分析方法", "url": "/posts/memory_footprint_analysis_method_for_embedded_systems/", "categories": "Embedded", "tags": "MCU", "date": "2021-07-25 07:59:00 +0800", "snippet": "1. 概述MCU 上的内存资源、flash 资源通常都比较紧张，程序比较复杂的时候，有可能会出现程序 RAM 或 flash 占用空间过大，导致系统运行不稳定（比如栈和堆空间冲突导致程序出现莫名其妙或者复位的问题），甚至是大小超过硬件资源限制，导致编译、烧录失败的问题。分析的基本方法大概有两种，一种是分析映射文件（*.map)，统计各个段的大小，另一种是从最终生成的可执行可链接文件（*.elf）中读取相关信息。2. 查看整个程序的占用空间(1) STM8L151x4/6以 STM8L151x4/6 为例，介绍第一种方法。首先要获取映射文件。以 ST Visual Develop 为例，打..." }, { "title": "Rust 笔记", "url": "/posts/rust_notes/", "categories": "Rust", "tags": "Rust", "date": "2021-07-23 20:49:00 +0800", "snippet": "1. 设置代理Windows 命令行代理设置set http_proxy=http://example.com:80set https_proxy=http://example.com:80:: 查看set http_proxyset https_proxyWindows PowerShell 代理设置$env:http_proxy=&quot;http://example.com:80&quot;$env:https_proxy=&quot;http://example.com:80&quot;#　查看ls env:http_proxyls env:https_proxyLinux 终..." }, { "title": "Rust 串口编程", "url": "/posts/rust_serial_programming/", "categories": "Embedded, Other", "tags": "SerialPort", "date": "2021-07-22 20:59:00 +0800", "snippet": "1. 背景如果使用 C 来编写 Linux 上的串口通信程序，需要使用 termios，tldp 有详细的示例：Serial-Programming-HOWTO。使用 Rust 编写串口通信程序，需要借助三个库：serial、ioctl-rs 以及 termios。serial 既支持 Linux，也支持 Windows，ioctl-rs 是对 Unix 上系统调用的部分 C 库的封装，termios 是对 Unix 上终端 I/O 的 C 库的封装，serial 依赖后面的两个库。2. 编码(1) 配置工程cargo new serial_port在配置文件中添加依赖：[depende..." }, { "title": "CRC-32学习笔记", "url": "/posts/crc_32/", "categories": "Rust", "tags": "CRC-32", "date": "2021-07-19 14:29:00 +0800", "snippet": "1. 关键字 正向校验（Normal）、反向校验（Reversed）[1] MSB、LSB2. 多项式\\[G(X) = X^{32} + X^{26} + X^{23} + X^{22} + X^{16} + X^{12} + X^{11} + X^{10} + X^{8} + X^{7} + X^{5} + X^{4} + X^{2} + X +1\\]正向：0x04C1_1DB7（实际是 0x1_04C1_1DB7 最前面的 1 通常不写出来）。反向：0xEDB8_8320（0x04C1_1DB7 反转）3. 基本算法(1) 正向校验 预置 1 个 32 位的变量 CRC，存放..." }, { "title": "加快访问 Coursera 的速度", "url": "/posts/speed_up_coursera_access/", "categories": "Other", "tags": "Other", "date": "2021-04-18 18:19:00 +0800", "snippet": "大多数情况下，在国内访问 Coursera 会比较慢，甚至会出现视频加载失败的问题。这是因为 DNS 被污染了，可以通过修改 hosts 的方式解决 DNS 污染问题。在这个 IPAddress.com 网站上查找如下三个域名对应的 IP 地址（一个域名可能会对应多个 IP 地址）： www.coursera.org d3c33hcgiwev3.cloudfront.net d3njjcbhbojbot.cloudfront.net如果是 Windows，使用记事本打开 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，将查到的 IP 地址和域名追加..." }, { "title": "STM8L SGP30 I2C 通信", "url": "/posts/stm8l_sgp30_i2c_communication/", "categories": "Embedded, MCU", "tags": "STM8", "date": "2021-04-18 18:19:00 +0800", "snippet": "最近使用 STM8L151K6T6 的硬件 I2C 接口和 SGP30 通信的过程中，遇到一个奇怪的问题：在发送完 “sgp30_iaq_int” 后的 15s 的传感器初始化时段内读取 CO2 和 TVOC 浓度没问题，但是 15s 之后会出现传感器不回应 Sr 之后的读请求的情况。一度以为 Sr 后发送的地址可能由于连线或者其他问题失真，传感器不应答。但是从逻辑分析仪的测量结果来看，地址是没有问题的。更奇怪的是，如果调试的时候，在发送 Sr 信号前添加断点，断住后再往下运行，传感器会回复 ACK，但是如果在发送 Sr 信号前添加延时，无论多久，传感器都不会回复 ACK。仔细阅读传感器..." }, { "title": "OpenWrt GPIO（MT7688AN）", "url": "/posts/openwrt_gpio_of_mt7688an/", "categories": "Embedded, OpenWrt", "tags": "OpenWrt", "date": "2021-03-20 10:00:00 +0800", "snippet": "1. 设备树在开发板上查看引脚使用情况：root@OpenWrt:~# cat /sys/kernel/debug/gpiogpiochip0: GPIOs 0-31, parent: platform/10000600.gpio, 10000600.gpio: gpio-6 ( |reboot ) in higpiochip1: GPIOs 32-63, parent: platform/10000600.gpio, 10000600.gpio: gpio-38 ( |rese..." }, { "title": "在树莓派上安装 PartKeepr", "url": "/posts/install_partkeepr_on_raspberry_pi/", "categories": "Toolbox, PartKeepr", "tags": "Inventory Management", "date": "2021-03-10 20:05:00 +0800", "snippet": "1. 背景本文是对官方 wiki 的粗略翻译（原文见[1]），文中使用 Apache 作为服务器。我试过使用 Nginx + php7.3-fpm 的组合，没有成功，安装进行到预热缓存的时后老是失败，估计对树莓派来说负荷有点重。2. 安装(1) 安装环境树莓派 3 B+，Raspbian GNU/Linux 10(2) 下载安装包下载安装包：partkeepr-1.4.0.tbz2sudo apt-get install phptar -xvjf partkeepr-1.4.0.tbz2sudo cp partkeepr-1.4.0 /var/www/partkeepr -rsudo c..." }, { "title": "PartKeepr（库存管理软件）安装", "url": "/posts/partkeepr_install/", "categories": "Toolbox, PartKeepr", "tags": "Inventory Management", "date": "2021-02-27 21:43:00 +0800", "snippet": "1. PartKeepr 介绍Parkeepr 是一款开源的库存管理软件（主要是为电子元器件管理设计的），用来管理手中的电子元器件、开发板是非常不错的。2. 安装(1) 安装环境Ubuntu 20.04.1 LTS, WSL(2) 下载安装包下载安装包：partkeepr-1.4.0.tbz2sudo apt-get install phptar -xvjf partkeepr-1.4.0.tbz2sudo cp partkeepr-1.4.0 /var/www/partkeepr -rsudo chown www-data:www-data /var/www/partkeepr -R#..." }, { "title": "使用 cmocka 进行单元测试", "url": "/posts/cmocka_tutorial/", "categories": "C, Unit Testing", "tags": "Unit Testing Framework", "date": "2021-02-23 21:46:00 +0800", "snippet": "1. cmocka 介绍cmocka 是一款简洁的 C 单元测试框架，支持打桩。它只依赖 C 标准库，可以运行在多种平台上（包括嵌入式环境）。2. 安装 cmocka从 cmocka.org 下载 cmocka 安装包或源码，例如，linux 上下载 cmocka-1.1.3.tar.xz 并解压：wget https://cmocka.org/files/1.1/cmocka-1.1.3.tar.xztar -xvJf cmocka-1.1.3.tar.xz按照源码包中的 INSTALL.md 内的指导进行编译安装，例如：cd cmocka-1.1.3mkdir buildcmake ..." }, { "title": "使用 FreeCAD 绘制螺纹", "url": "/posts/make_threaded_part_in_freecad/", "categories": "3D Printing, FreeCAD", "tags": "3D Printing", "date": "2021-01-31 20:12:00 +0800", "snippet": "1. 背景FreeCAD 版本：0.182. 绘制螺纹的几种方式FreeCAD 官方 wiki 上，Thread for Screw Tutorial[1] 中介绍了绘制螺纹的 6 种方法： 0：从部件库里面获取符合 ISO 标准的紧固件 1：使用宏（已经不推荐了） 2：制作假螺纹（没有螺旋） 3：拿竖直方向的轮廓沿竖直方向的螺旋线扫掠 4：拿水平方向的轮廓沿竖直方向的螺旋线扫掠 5：从螺旋挤压的两个面之间放样个人感觉如果是非标准件的话，选用方法 3 比较合适：拿竖直方向的轮廓沿竖直方向的螺旋线扫掠。wiki 上的方法 3 步骤有点问题，比如在第 8 步中创建增料圆柱体时，在..." }, { "title": "ThingsBoard3.1 安装", "url": "/posts/thingsboard_install/", "categories": "IoT, Server", "tags": "ThingsBoard", "date": "2021-01-30 20:58:00 +0800", "snippet": "1. Linux(1) 安装 ThingsBoard 服务sudo dpkg -i thingsboard-3.1.deb(2) 安装 java 8sudo apt install openjdk-8-jdksudo update-alternatives --config java(3) 安装 PostgreSQL# install **wget** if not already installed:sudo apt install -y wget# import the repository signing key:wget --quiet -O - https://www.post..." }, { "title": "ThingsBoard MQTT over SSL", "url": "/posts/thingsboard_mqtt_over_ssl/", "categories": "IoT, Server", "tags": "ThingsBoard", "date": "2021-01-24 22:37:00 +0800", "snippet": "1. 背景ThingsBoard 版本：3.12. 后台配置(1) Linux生成自签证书从 ThingsBoard仓库 下载这三个文件： client.keygen.sh keygen.properties server.keygen.sh修改 keygen.properties 中的内容，务必将 $(hostname) 替换为 ip 或域名，其余的根据需要修改：# DOMAIN_SUFFIX=&quot;$(hostname)&quot;DOMAIN_SUFFIX=&quot;localhost&quot;依次运行 server.keygen.sh 和 client.keyge..." }, { "title": "ThingsBoard UI 修改", "url": "/posts/thingsboard_ui_customization/", "categories": "IoT, Server", "tags": "ThingsBoard", "date": "2021-01-24 08:23:00 +0800", "snippet": "1. 背景需要在 ThingsBoard 页面下面添加页脚标签，首先想到的是可不可以修改配置文件或者安装目录内的一些 html 文件来完成添加，检索之后发现该方法不可行，原因是 html 页面都被编译到 thingsboard.jar 文件中去了，无法直接修改。另一种思路就是修改 ThingsBoard 的源码，然后再编译。版本：3.12. 添加页脚标签下载源码：https://github.com/thingsboard/thingsboard检出所需版本，例如：git checkout release-3.1修改 ui-ngx/src/index.html 文件，添加 footer ..." }, { "title": "某次 debug 过程记录", "url": "/posts/%E6%9F%90%E6%AC%A1debug%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/", "categories": "Embedded, MCU", "tags": "IoT, STM8, Rust", "date": "2020-09-21 22:55:00 +0800", "snippet": "1. 故障服务器上未看到某个节点的数据。2. 使用伪代码分析节点代码（分析后发现潜在问题蛮多的）main 函数初始化硬件初始化 OS如果初始化成功{ 使能滴答时钟 创建 main_thread 如果创建成功{ 启动 OS （不会返回） }}loop{} // 如果前面的流程出错，会运行到这个地方main_thread：剩余发送尝试次数赋初始值获取序列号射频驱动初始化初始化数据缓冲区loop{ 打印时间 如果剩余发送尝试次数没变{ 读传感器数据 封装数据 打印 封装好的数据 } 信道活跃检测，最多三次 如果检测超时{ 打印 检测超时 // to do：需要处理超时的情况 } ..." }, { "title": "自由使用 Dragino 网关 MCU 串口", "url": "/posts/use_dragion_lg01p_serial_port/", "categories": "Embedded, OpenWrt", "tags": "OpenWrt", "date": "2020-08-20 23:41:00 +0800", "snippet": "网关Dragino LG01-P LoRa GatewayLinux Side: Processor: AR9331 Frequency: 400MHz Flash: 16MB RAM: 64MB MCU/LoRa Side: MCU: ATMega328P Flash: 32KB RAM: 2KB LoRa Chip: SX2176/78 网关设计应该借鉴了 Arduino Yun，运行 OpenWRT 系统。串口和 MCU 相连的串口 /dev/ttyATH0 和 /dev/c..." }, { "title": "Cross Compile Rust For OpenWRT", "url": "/posts/cross-compile-rust-for-openwrt/", "categories": "Rust", "tags": "", "date": "2020-08-09 00:57:29 +0800", "snippet": "1. 背景编译环境（x86_64，Windows Subsystem for Linux）： OpenWRT SDK: OpenWrt-SDK-ar71xx-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2 工具链目录：/mnt/f/wsl/OpenWRT/OpenWrt-SDK-ar71xx-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2 rust 版本：1.46.0（官方不会构建 uclibc 的版本，所以有些版本下，uclibc 会编译失败，例如 1...." }, { "title": "Simplify 3D 使用笔记", "url": "/posts/Simplify3D%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/", "categories": "3D Printing, Simplify 3D", "tags": "", "date": "2019-04-23 21:53:00 +0800", "snippet": "1. 挤出头挤出宽度：增大挤出宽度可以加快打印速度，设置为喷嘴直径的90%~150%。如果出现水平方向缝隙过大的情况，可以适当增大挤出宽度。回抽长度：挤出机反转，将耗材从喷嘴里抽出的距离。近程挤出一般设1-3mm，远程挤出一般设4-8mm。如果喷头空走时拉丝漏料比较多，可适当增加回抽长度，具体数值需要自己根据打印机和耗材性能进行测试。2. 层层高：一般设置为喷嘴直径的20%~80%，越小越精细，越大打印时间越短，一般设置为0.1mm。过小的层高，挤出机很难稳定挤出，会导致模型表面反而不如0.1mm层高时光滑。首层高度：不加衬垫的情况下，设大一点，可以是模型更好的粘附平台。首层降速：不加衬..." }, { "title": "ThingsBoard - MQTT", "url": "/posts/ThingsBoard-MQTT/", "categories": "IoT, MQTT", "tags": "MQTT, ThingsBoard", "date": "2019-01-13 12:30:00 +0800", "snippet": "1. 建立网关设备 -&amp;gt; 添加新设备 -&amp;gt; 输入名称、类型，并勾选 是网关2. 获取网关的访问令牌设备 -&amp;gt; 点击添加的网关 -&amp;gt; 复制访问令牌3. 上传测试数据终端消息体示例：&quot;{&quot;SN-002&quot;: [{&quot;ts&quot;: 1548434563634,&quot;values&quot;: {&quot;temperature&quot;: 26.15,&quot;humidity&quot;: 41.66,&quot;voltage&quot;: 3.86,&quot;rssi&quot..." }, { "title": "Nginx 反向代理 Thingsboard 并缓存静态文件", "url": "/posts/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86thingsboard%E5%B9%B6%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/", "categories": "IoT, Server", "tags": "ThingsBoard, Nginx", "date": "2018-02-08 20:45:00 +0800", "snippet": "1. 背景使用浏览器访问 ThingsBoard 时速度较慢，原因是有个 CSS 文件体积较大（超过 2 M）。2. 安装配置 NginxCentos 安装 Nginx：# yum install nginx创建缓存目录：mkdir -pv /cache/nginx/chown -R nginx:nginx /cache/nginx创建配置文件：vim /etc/nginx/conf.d/thingsboard.confproxy_cache_path /cache/nginx/ levels=1:2 keys_zone=STATIC:50m max_size=2G inactive=3..." }, { "title": "Eagle 输出 PCB 制造数据", "url": "/posts/generate_manufacturing_data_from_eagle/", "categories": "Embedded, PCB", "tags": "", "date": "2017-11-14 10:31:00 +0800", "snippet": "某宝上的电路板制造商的软件支持列表中，几乎是没有 Eagle 的。遇到这种情况，就不能像使用 Altium Designer 那样直接把 pcb 文件发给制造商来制板了。不过，我们可以使用 Eagle 的 CAM 处理程序生成制造数据（钻孔数据以及 Gerber 光绘信息数据），把生成的数据交给电路板制造商就可以制板了。1. 制造数据清单   文件 选中的层 描述 1 %N.drd 44 Drills 电镀孔 2 %N.hol ..." }, { "title": "Arduino存储器", "url": "/posts/arduino_memories/", "categories": "Embedded, MCU", "tags": "IoT, Arduino", "date": "2017-08-29 09:09:00 +0800", "snippet": "Arduino有三种类型的存储器： Flash or Program Memory SRAM（Static Random Access Memory） EEPROM（Electrically Erasable Programmable Read and Write Memory）(1) Flash MemoryFlash用于储存程序镜像以及初始化数据。Flash是非易失性存储器，因此，系统掉电后，程序依然储存在里面。Flash的擦写寿命大概为10万次。(2) SRAMSRAM可以在程序运行时读写，常被用于以下目的： Static Data：这个区块用于储存程序中所..." }, { "title": "Kura Mosquitto TLS", "url": "/posts/Kura-Mosquitto-TLS/", "categories": "IoT, MQTT", "tags": "MQTT, Kura, Mosquitto", "date": "2017-07-06 11:27:00 +0800", "snippet": "前提：服务器开启8883端口。1. 双向验证双向验证的前提是服务器有域名。(1) 在服务器上创建 CA可以通过脚本创建：# wget https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh打开脚本查看用法。也可以逐条运行命令创建：生成无需密码保护的密钥对# openssl genrsa -out ca.key 1024生成自签名证书# openssl req -new -x509 -key ca.key -out ca.crt -days 3650 ----- Country Name (2 lette..." }, { "title": "Contiki 功耗评估", "url": "/posts/Contiki%E5%8A%9F%E8%80%97%E8%AF%84%E4%BC%B0/", "categories": "IoT, WSN", "tags": "Contiki", "date": "2017-06-20 09:20:00 +0800", "snippet": "1. 前言在无线传感器网络中，网络节点的功耗是一个很重要的问题。通常情况下，为了节省能量，传感器节点会关闭射频接收器，这些射频接收器仅仅在接收来自其他节点（例如，邻居节点）的数据包时打开。这个方法的原理是，当传感器节点无需接收数据时，能量消耗是最少的。然而，在某些应用中，这个方法很可能是无效或者干脆不能被使用。在Contiki中，MAC 和 RDC（Radio Duty Cycling）在通信协议栈中的地位非常重要，因为它们会直接影响传感器节点的总功耗。Contiki中集成了多种RDC驱动，例如：ContikiMAC、X-MAC、LPP 以及 NullRDC。RDC 驱动会尽可能的关闭射..." }, { "title": "LoRa教程", "url": "/posts/lora_tutorial/", "categories": "IoT, LoRa", "tags": "LoRa", "date": "2017-06-11 15:18:00 +0800", "snippet": "1. 概览LoRa技术是一种广域网无线通信技术。基于LoRa无线通信技术的网络有多种不同的频段：902-928Hz（美国）、863-928Hz（欧盟）、779-787Hz（中国）等。LoRa是一种低功耗、长距离以及低通信速率的技术，最初由Samtech开发。LoRa网络由网关、网络服务器以及终端设备组成，类型为星型。在LoRa网络系统中，终端设备也被称为motes，网关也被称为基站（base stations）或者集中器（concentratrators）。终端和网关使用特定的ISM频段进行单跳连接。网关和网络服务器之间通过Ip回程线路连接（IP backhaul）。上图描绘了LoRa网..." }, { "title": "Contiki OS for cc2530F256", "url": "/posts/Contiki-OS-for-cc2530F256/", "categories": "Embedded, MCU", "tags": "Contiki", "date": "2016-12-23 11:05:00 +0800", "snippet": "1. 写在前面平台：CC2530在Ubuntu 16.04上搭建Contiki的开发环境的过程中，遇到一系列问题，总体来说，开发环境搭建工作是失败的。只能下载官方已经搭建好开发环境的系统虚拟磁盘文件InstantContiki2.7.zip，该镜像基于Ubuntu 12.04 32bit。InstantContiki2.7.zip然后在 VirtualBox 上创建 32 位的 Ubuntu 系统，选择下载好的虚拟磁盘文件，创建虚拟系统，登录密码为 user。系统自带了 contiki2.6 和 contiki2.7 的源码，需要注意的是，不管是 2.6、2.7 还是从 Github 上..." }, { "title": "SDCC for Contiki", "url": "/posts/sdcc-for-contiki/", "categories": "Embedded, MCU", "tags": "Contiki", "date": "2016-12-23 09:41:00 +0800", "snippet": "1. 背景平台：CC2530F256系统环境：InstantContiki2.7 Ubuntu 12.04 32bit2. 安装前的准备$ sudo apt-get install libboost-graph-dev srecord下载SDCC源码后，需要对源码进行一些修改：编辑“device/lib/incl.mk”，找到103行的：MODELS = small medium large改为：MODELS = small large huge编辑“device/lib/Makefile.in”，找到187行的：TARGETS += models small-mcs51-stack-a..." }, { "title": "Eagle 设置过孔盖油/开窗", "url": "/posts/Eagle%E8%AE%BE%E7%BD%AE%E8%BF%87%E5%AD%94%E7%9B%96%E6%B2%B9%E6%88%96%E5%BC%80%E7%AA%97/", "categories": "Embedded, PCB", "tags": "", "date": "2016-10-18 11:05:00 +0800", "snippet": "预览 Gerber 文件时，阻焊层所指示的区域之外都是要覆盖绿油的。使用 Eagle 输出 Gerber 文件时的设置： 顶层阻焊层仅选中第 29 层（tStop） 底层阻焊层仅选中第 30 层（bStop）过孔盖油 设置：编辑—&amp;gt;设计规则—&amp;gt;Masks—&amp;gt;Limit为板上最大的过孔外径（在工具—&amp;gt;统计—&amp;gt;VIA中可以看到）。 输出的Gerber文件中，阻焊层所指示的区域不应包含过孔。过孔开窗 设置：编辑—&amp;gt;设计规则—&amp;gt;Masks—&amp;gt;Limit为0mm。 输出的Ge..." }, { "title": "STM8 开发环境搭建", "url": "/posts/STM8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Embedded, MCU", "tags": "STM8", "date": "2016-06-14 10:23:00 +0800", "snippet": "(1) 下载ST Visual develop IDE到ST官网上搜索STVD，列表中选择“STVD-STM8”下载安装即可。(2) 安装CXSTM8访问http://www.cosmicsoftware.com/，填写注册信息后下载，安装过程中按照指引发送电子邮件申请“license.lic”，大概一天左右可以收到。如果是使用过程中许可证过期，需要运行安装目录下的COSMIC\\FSE_Compilers\\CXSTM8\\Register.bat脚本重新注册。(3) 下载STM8标准外设库到st官网，搜索具体的微控制器型号，然后在“工具和软件”列表中的“软件”选项卡下下载对应的Standa..." }, { "title": "MQTT Embeded 学习笔记（订阅消息）", "url": "/posts/MQTT-Embeded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-subscribe/", "categories": "IoT, MQTT", "tags": "MQTT, ESP8266", "date": "2016-04-27 10:09:00 +0800", "snippet": "MQTTSNPacket/samples文件夹下有向服务器订阅消息的例程，如”pub0sub1.c”。下面仍旧以ST-NUCLEO-F103RB和ESP8266为例，说一下使用MQTTPacket如何向服务器订阅消息（未提到的部分请参阅《MQTT Embedded学习笔记（发布）》）。1. 例程解读“pub0sub1.c”中main()函数主要有以下几部分：(1) 发送CONNECT命令主要的代码为：len = MQTTSerialize_connect(buf, buflen, &amp;amp;data);这行代码将含有CONNECT命令的信息串行化后放在buf里面。(2) 接收CO..." }, { "title": "MQTT V3.1.1学习笔记（剩余长度编码规则）", "url": "/posts/MQTT_V3_1_1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%89%A9%E4%BD%99%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/", "categories": "IoT, MQTT", "tags": "MQTT", "date": "2016-04-06 18:21:00 +0800", "snippet": "固定报头中的剩余长度是指当前数据包中剩余的字节数，包括可变报头及有效荷载。剩余长度字段从第二个字节起，数据储存遵循大端模式（高字节在前，低字节在后）。对于长度小于等于127个字节的消息，可变程度编码方案使用一个单独的字节。长度大于127个字节的消息，使用如下方案处理：每个字节的最低的7位编码数据（最大为127），最高位用来指明还有后续字节。可变长度区域所用的最大字节数为4。能代表的最大的数为268,435,455（256MB），编码为：0xFF，0xFF，0xFF，0x7F。编码、解码的C语言实现如下：#include &quot;stdio.h&quot;#include &quot;..." }, { "title": "MQTT Embeded 学习笔记（发布消息）", "url": "/posts/MQTT-Embeded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-publish/", "categories": "IoT, MQTT", "tags": "MQTT, STM32, ESP8266", "date": "2016-03-30 15:45:00 +0800", "snippet": "1. PahoEclipse 的 Paho 项目旨在提供可伸缩的开放和标准的 Machine-to-Machine (M2M) 以及物联网消息协议的开源实现。Paho 提供了许多不同版本的 MQTT client 以供不同平台使用。其中，Embedded MQTT C/C++ Client Libraries 是为嵌入式平台提供的，可以将其用在 mbed、Arduino、FreeRTOS 等环境中。2. Embedded MQTT C/C++ Client LibrariesEmbedded MQTT C/C++ Client Libraries包含三部分内容：MQTTPacket、MQ..." }, { "title": "Mosquitto 笔记", "url": "/posts/Mosquitto%E7%AC%94%E8%AE%B0/", "categories": "IoT, MQTT", "tags": "MQTT, ESP8266", "date": "2016-03-29 00:09:00 +0800", "snippet": "1. MQTTMQTT（MQ Telemetry Transport）是轻量级的消息传输协议，它允许设备高效地通过受限网络与远程系统进行异步通信。MQTT的特点 发布/订阅模式可以提供一对多的消息发布，解除了应用程序之间的耦合 消息传输屏蔽了报文的内容 使用TCP/IP提供基本的网络连接 三种用于消息分发的质量服务： “至多一次” “至少一次” “只有一次” 传输开销很小（固定长度的报头只有两字节），协议交换最小化，以减少网络流量 使用Last Will和Test..." }, { "title": "触摸屏与LCD坐标转换", "url": "/posts/%E8%A7%A6%E6%91%B8%E5%B1%8F%E4%B8%8ELCD%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/", "categories": "Embedded, Other", "tags": "", "date": "2015-08-25 00:11:28 +0800", "snippet": "想要弄明白LCD屏幕坐标和触摸屏坐标的关系，得先从LCD触摸屏的结构说起。一般我们接触到的触摸屏都有两层，一层是纯粹的LCD液晶显示面板，其上就是一层透明的触摸屏薄膜。要说的是，LCD显示屏和触摸屏都有各自的分辨率指标，也就相当于它们的坐标系，现假定他们的坐标系分别为（x,y）和(X,Y)。就像我所测试的LCD显示屏的分辨率为1024*600，它的坐标原点（0，0）是左上角，右下角坐标为（1024，600）,而触摸屏也有它本身的坐标原点O（物理的，固定的，在屏幕中的某一位置，很可能该原点在装配过程中已经被切割掉，但没关系，不影响坐标确定）。在实际使用过程中，我们不会关心某个时刻触摸屏的具..." }, { "title": "Linux 串口编程", "url": "/posts/linux-serial-programming/", "categories": "Linux", "tags": "", "date": "2015-08-25 00:11:28 +0800", "snippet": "信号驱动的IO信号驱动的IO是一种半异步的IO模型。使用信号驱动I/O时，当网络套接字可读后，内核通过发送SIGIO信号通知应用进程，于是应用可以开始读取数据。具体的说，程序首先允许套接字使用信号驱动I/O模式，并且通过sigaction系统调用注册一个SIGIO信号处理程序。当有数据到达后，系统向应用进程交付一个SIGIO信号，然后应用程序调用read函数从内核中读取数据到用户态的数据缓存中。这样应用进程都不会因为尚无数据达到而被阻塞，应用主循环逻辑可以继续执行其他功能，直到收到通知后去读取数据或者处理已经在信号处理程序中读取完毕的数据。设置套接字允许信号驱动IO的步骤如下： ..." }, { "title": "触摸屏校准", "url": "/posts/%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%A0%A1%E5%87%86/", "categories": "Embedded, RaspberryPi", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "树莓派，使用 tslib 校准 egalax 触摸屏。添加egalax USB触摸屏驱动需要为树莓派编译内核：sudo apt-get install git-core gcc-4.7-arm-linux-gnueabisudo ln -s /usr/bin/arm-linux-gnueabi-gcc-4.7 /usr/bin/arm-linux-gnueabi-gccmkdir raspberrypicd raspberrypigit clone https://github.com/raspberrypi/tools.gitgit clone https://github.com/r..." }, { "title": "安装 QtSerialPort", "url": "/posts/%E5%AE%89%E8%A3%85QtSerialPort/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "1. 编译安装git clone git://gitorious.org/qt/qtserialport.gitcd qtserialportqmake qtserialport.promakesudo make installQtSerialPort库将会被安装至Qt的lib目录下，例如：/usr/local/Trolltech/Qt-4.8.6/lib/libQtSerialPort.so.1.02. 使用在 *.pro 文件中添加下列内容：CONFIG += serialport注意为嵌入式版本安装时，采用qtcreator的安装方式安装，否则依旧会被安装在桌面版的目录下。 do..." }, { "title": "使 Qt 获取 event 的读写权限", "url": "/posts/%E4%BD%BFQt%E8%8E%B7%E5%8F%96event%E7%9A%84%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "实际上是对当前用户赋予/dev/input/event*的读写权限。$ sudo addgroup input$ sudo usermod -a -G input debian有多种方案，列出两种。方案一$ vim /etc/init.d/rc.local添加下列内容：chgrp input /dev/input/event1chmod 660 /dev/input/event1有时候会不起作用。方案二使用root权限创建规则文件：$ sudo vim /etc/udev/rules.d/99-input.rules加入如下内容：KERNEL==&quot;event*&quot;, N..." }, { "title": "C++ 读写 xls 文件", "url": "/posts/read-write-xls-file-in-c-plus-plus/", "categories": "Other", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "下载源码下载：xlslib-package-2.5.0.zip平台： Ubuntu 14.04 64bitsg++， version 4.6-4.8无法编译xlslibsudo apt-get install g++-4.4编译安装export CC=gcc-4.4 CXX=g++-4.4 ./configure makesudo make install使用g++ main.cpp -I/usr/local/include/xlslib -lxls" }, { "title": "Eagle PCB 拼板", "url": "/posts/eagle-pcb-panelize/", "categories": "Embedded, PCB", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "1. 操作步骤(1) 在 eagle 中新建一个 PCB 文件并保存，作为拼板文件。(2) 只打开需要拼板的 brd 文件，保持原理图为关闭状态。(3) 打开用户语言程序 panelize.ulp，在弹出的对话框中点击 Execute，如果是单面板的话，图层中会出现第125层（_tName层），如果是双面板，除出现第125层外还会出现第126层（_bName 层）。运行 panelize.ulp 程序之前：运行 panelize.ulp 程序之后：元件的名称被复制到了 _tName 层。(4) 运行 Copy 命令，然后运行 Group 命令，框选整个 PCB 图，右击，选择 Copy：..." }, { "title": "Windows(64位)下Qt(4.8.6)开发环境搭建", "url": "/posts/Windows%E4%B8%8BQt(4.8.6)%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "1. 安装 MinGw下载： MinGW wiht GCC 4.8.2而后将其解压，将 mingw32 文件复制到安装目录下，例如：E:\\然后将bin文件目录加入系统环境变量中：E:\\mingw32\\bin2. 安装 Qt下载： qt-opensource-windows-x86-mingw482-4.8.6-1.exe安装过程中指定 MinGW 所在目录。3. 安装qwt下载：qwt-6.1.0.zip，将压缩包解压。从 QT Command Pormpt 进入解压后的文件夹中，运行以下命令：qmakemake#使用安装目录替换$INSTALL_DIRECTORYmake instal..." }, { "title": "Ubuntu(64位)下Qt(4.8.6)桌面版开发环境搭建", "url": "/posts/Ubuntu%E4%B8%8BQt(4.8.6)%E6%A1%8C%E9%9D%A2%E7%89%88%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "安装Qt下载：qt-everywhere-opensource-src-4.8.6.tar.gz安装见 INSTALL 文件。安装qwt下载：qwt-6.1.0.zip，将压缩包解压。打开qwt源码包中的qwtconfig.pri文件,找到：QWT_INSTALL_PREFIX = /usr/local/qwt-$$QWT_VERSION将其修改为：QWT_INSTALL_PREFIX = /usr/local/Trolltech/qwt-$$QWT_VERSION-Desktop逐条运行下列命令：/usr/local/Trolltech/Qt-4.8.6/bin/qmake..." }, { "title": "Qt 应用程序读写 xls 文件", "url": "/posts/Qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%86%99xls%E6%96%87%E4%BB%B6/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "下载：xlslib-package-2.5.0.zipLinux X11版平台： Ubuntu 14.04 64bitsg++， version 4.6-4.8无法编译xlslibsudo apt-get install g++-4.4编译安装export CC=gcc-4.4 CXX=g++-4.4 ./configure makesudo make install安装完成后，将/usr/local/lib文件夹下的xls库文件拷贝到Qt的lib目录下sudo cp /usr/local/lib/libxls* /usr/local/Trolltech/Qt-4.8.6/lib/使用在..." }, { "title": "Qt/Embeded(4.8.6)交叉编译环境搭建", "url": "/posts/Qt_Embedded(4.8.6)%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Embedded, Qt", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "目标板为树莓派，安装镜像为：2014-12-24-wheezy-raspbian.img安装交叉编译器：下载：gcc-linaro-arm-linux-gnueabihf-raspbian-x64解压后将bin目录添加进~/.profile文件中，例如： PATH=/home/qianchen/rpi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin:$PATH export PATH运行以下命令： source ~/.profile在Qt Creator中添加交叉编译器工具-&amp;gt;选项-&amp..." }, { "title": "IAR 编译 ZStack-CC2530 生成 HEX 文件", "url": "/posts/IAR%E7%BC%96%E8%AF%91ZStack-CC2530%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/", "categories": "Embedded, MCU", "tags": "", "date": "2015-08-25 00:11:26 +0800", "snippet": "IAR 编译 ZStack-CC2530 为可下载运行的 HEX 文件的正确配置： 正确配置输出文件格式：菜单选择Project－Options－Linker－Output－Format，选择Other。右边的Output下拉框选intel-extended，Format variant下拉框选None，Module-local下拉框选Include all 还是在菜单Project－Options－Linker－Output标签中，勾上Override default选项，把编辑框中的文件名的后缀改为hex 以上两步都是大多数人熟知的，下面这一步是针对大型程序..." } ]
